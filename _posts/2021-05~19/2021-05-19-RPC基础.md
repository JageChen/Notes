---
layout: post
title:  "RPC 基础"
date:  2021-05-19
tags: [RPC]
commentIssueId: 5


---



RPC 基础

---

* **RPC是什么？**

  RPC全称 -> remote procedure call （远程过程调用）字面意思远程调用非本机之间的操作.

* **RPC 架构有哪些？**

  * 传输模块也简称传输协议，例如默认的TCP协议.

  * 序列化模块也叫协议封装，将参数转成可传输的二进制.

  * 数据压缩模块，将大的二进制数据进行压缩，避免多的断续多传

  * bean模块也叫Bootstrap 模块，rpc接口交给spring factory管理让调用者可以通过spring依赖注入的方式进行引用。

  * 服务发现 上述几个功能可以组件一个简单的rpc了，但是可能存在多版本多提供方的接口所以还需要加上该模块提供接口和服务提供方地址映射的查找问题.
  * TCP连接管理区，每次RPC都是需要tcp连接的，所以tcp连接状态管理也很重要.
  * 最后有一些服务治理的功能，例如负载权重，授权，配置等

* **怎么设计可扩展的协议？**

  每次RPC请求参数可能都是大小不固定的，所以得告之接收方当前消息的长度是多少，这里设置一个协议长度，然后再根据协议长度读取相应大小的协议体，协议目前设计如下所示

  ​						协议长度|协议体

  上面只是简单的做了一个可以通讯的协议，但是接收方并不知晓当前序列化的类型是什么，所以还得加一个序列化方式，上述的**协议长度和序列化方式可以统称为协议头**，这阶段的协议涉及如下

  ​						协议头|协议体

  以 Dubbo 为例，消费者发送请求时，使用 AtomicLong 自增，产生一个 消息 ID。由于 Dubbo 底层 IO 操作是异步的，Dubbo 发送请求之后，需要阻塞等待消费者返回信息。消费者会将消息 ID 保存到 Map 结构中,。为了保证请求响应可以一一对应，这就需要提供者返回的响应信息带上请求者消息 ID。 通过响应的消息 ID，通过 上面提到 Map 存储数据，就能找到对应的请求.

  所以协议头上还需要增加消息ID这样的参数。

  上述就是一个简单完整的协议,但是这还存在一个问题不可扩展。

  所以为了后续协议可扩展可以在协议头中扩展不固定参数，此参数可以定义为后续协议扩展的字段.最后完整的协议如下.

  ​             整体长度|头长度|协议版本|序列化方式|消息id|协议头可扩展字段|协议体

* **RPC网络**

    我觉得本身这一块是没有什么好讲的，因为网络这块的基础就是io，可以去了解下各种io，零拷贝是如何实现的，neety的零拷贝做了什么.



​				